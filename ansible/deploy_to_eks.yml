---
- name: Deploy Containerized Application and Monitoring to AWS EKS
  hosts: localhost
  connection: local
  gather_facts: false

  # Variables passed from Jenkins: image_tag, ecr_uri, kubeconfig_path
  
  tasks:
    # ----------------------------------------------------
    # TASK 1: Deploy Kube-Prometheus Stack (Monitoring Base)

   # In your ansible/deploy_to_eks.yml playbook, under tasks:

    # 1. Ensure Helm Repository is added (Fixes "repo prometheus-community not found")
    - name: Add Prometheus community Helm repository
      community.kubernetes.helm_repository:
        name: prometheus-community
        repo_url: https://prometheus-community.github.io/helm-charts
        state: present

    # 2. Ensure 'monitoring' Namespace exists
    - name: Ensure 'monitoring' namespace exists
      community.kubernetes.k8s:
        name: monitoring
        api_version: v1
        kind: Namespace
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        
    # 3. Deploy Kube-Prometheus Stack (Fixes "missing required arguments" and "missing: chart_ref")
    - name: Ensure kube-prometheus-stack is deployed via Helm
      community.kubernetes.helm: 
        name: prometheus-stack             
        namespace: monitoring             
        chart_ref: prometheus-community/kube-prometheus-stack 
        release_state: present
        # ðŸš¨ FIX: Replaced 'update_repo' with the supported 'update_repo_cache'
        update_repo_cache: true 
        kubeconfig: "{{ kubeconfig_path }}"
        values:
          # Disable Grafana as it's running externally on the EC2 instance
          grafana:
            enabled: false
          # Expose Prometheus via NodePort for the external Grafana EC2 to access
          prometheus:
            service:
              type: NodePort

    # ----------------------------------------------------
    # TASK 2: Deploy Custom Application and Service Monitors
    # ----------------------------------------------------
    - name: Apply application deployment, service (NodePort), and custom ServiceMonitors
      community.kubernetes.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}" 
        # Application deployment goes to the 'default' namespace
        namespace: default
        # Apply the list of files required for the app and its monitoring
        src: "{{ item }}"
      loop:
        # 1. Application Deployment/Service (Injects dynamic image tag and uses NodePort)
        - "{{ playbook_dir }}/../k8s/deployment.yml.j2" 
        # 2. Application Service Monitor (to enable Prometheus scraping of app metrics)
        - "{{ playbook_dir }}/../k8s/app-servicemonitor.yml" 
        
    # ----------------------------------------------------
    # TASK 3: Deploy Jenkins ServiceMonitor (External Scrape)
    # ----------------------------------------------------
    - name: Apply Jenkins external Service and Endpoint for monitoring
      community.kubernetes.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        # Jenkins monitor configuration must go to the 'monitoring' namespace
        namespace: monitoring
        src: "{{ playbook_dir }}/../k8s/jenkins-monitor.yml"

    # ----------------------------------------------------
    # TASK 4: Deployment Verification (Similar to original task)
    # ----------------------------------------------------
    - name: Use kubernetes.core.k8s to apply deployment manifest
      # This final task from your original plan is technically redundant 
      # since we used the 'k8s' module in Task 2, but kept for reference.
      community.kubernetes.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        namespace: default
        template: "{{ playbook_dir }}/../k8s/deployment.yml.j2"
        wait: true
        wait_timeout: 600
      vars:
        image_full_uri: "{{ ecr_uri }}:{{ image_tag }}"

---
- name: Deploy Containerized Application and Monitoring to AWS EKS
  hosts: localhost
  connection: local
  gather_facts: false

  # Variables passed from Jenkins: image_tag, ecr_uri, kubeconfig_path
  
  tasks:
    # ----------------------------------------------------
    # TASK 1: Deploy Kube-Prometheus Stack (Monitoring Base)
    # ----------------------------------------------------
    - name: Ensure kube-prometheus-stack is deployed via Helm
      # This task installs Prometheus, Grafana, and Alertmanager
      community.kubernetes.helm: 
        name: prometheus-stack
        chart_ref: prometheus-community/kube-prometheus-stack
        release_namespace: monitoring
        create_namespace: true
        kubeconfig: "{{ kubeconfig_path }}"
        state: present
        # Setting Grafana service type to NodePort is usually not necessary 
        # as access is often via port-forwarding or a separate Ingress, 
        # but leaving it as default or LoadBalancer simplifies initial access.
        # [cite_start]We assume Prometheus monitoring deployment is to meet the project goal[cite: 28].

    # ----------------------------------------------------
    # TASK 2: Deploy Custom Application and Service Monitors
    # ----------------------------------------------------
    - name: Apply application deployment, service (NodePort), and custom ServiceMonitors
      community.kubernetes.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}" 
        # Application deployment goes to the 'default' namespace
        namespace: default
        # Apply the list of files required for the app and its monitoring
        src: "{{ item }}"
      loop:
        # 1. Application Deployment/Service (Injects dynamic image tag and uses NodePort)
        - "{{ playbook_dir }}/../k8s/deployment.yml.j2" 
        # 2. Application Service Monitor (to enable Prometheus scraping of app metrics)
        - "{{ playbook_dir }}/../k8s/app-servicemonitor.yml" 
        
    # ----------------------------------------------------
    # TASK 3: Deploy Jenkins ServiceMonitor (External Scrape)
    # ----------------------------------------------------
    - name: Apply Jenkins external Service and Endpoint for monitoring
      community.kubernetes.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        # Jenkins monitor configuration must go to the 'monitoring' namespace
        namespace: monitoring
        src: "{{ playbook_dir }}/../k8s/jenkins-monitor.yml"

    # ----------------------------------------------------
    # TASK 4: Deployment Verification (Similar to original task)
    # ----------------------------------------------------
    - name: Use kubernetes.core.k8s to apply deployment manifest
      # This final task from your original plan is technically redundant 
      # since we used the 'k8s' module in Task 2, but kept for reference.
      community.kubernetes.k8s:
        state: present
        kubeconfig: "{{ kubeconfig_path }}"
        namespace: default
        template: "{{ playbook_dir }}/../k8s/deployment.yml.j2"
        wait: true
        wait_timeout: 600
      vars:
        image_full_uri: "{{ ecr_uri }}:{{ image_tag }}"
